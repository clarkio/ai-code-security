"use strict";

// Note the code generated by o3-mini-high is using the old require pattern
// which will result in errors/warnings from VS Code and ESLint such as
// "This expression is not callable."
const express = require('express');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const session = require('express-session');
const SQLiteStore = require('connect-sqlite3')(session);
const csurf = require('csurf');
const bcrypt = require('bcrypt');
const { Sequelize, DataTypes } = require('sequelize');

const app = express();

/* ==========================================
   Security Middlewares & App Configuration
   ========================================== */

// Set secure HTTP headers
app.use(helmet());

// Parse JSON and URL-encoded bodies
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Global rate limiter: Limit each IP to 100 requests per 15 minutes
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100
});
app.use(limiter);

// Configure sessions (ensure you use a strong secret via environment variable)
app.use(session({
  store: new SQLiteStore(),
  secret: process.env.SESSION_SECRET || 'your-very-secure-secret-here',
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // Requires HTTPS in production
    sameSite: true
  }
}));

// CSRF protection – this must come after the session middleware
app.use(csurf());

// Make CSRF token available to clients (for example, to be used in AJAX requests)
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken();
  next();
});

/* ==========================================
   Database Setup (Using Sequelize & SQLite)
   ========================================== */

// For demonstration we’re using SQLite. In production, choose a more robust DB.
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: './database.sqlite',
  logging: false // Disable logging in production
});

// Define the User model
const User = sequelize.define('User', {
  username: {
    type: DataTypes.STRING(50),
    unique: true,
    allowNull: false
  },
  passwordHash: {
    type: DataTypes.STRING,
    allowNull: false
  }
});

// Define the Note model
const Note = sequelize.define('Note', {
  content: {
    type: DataTypes.TEXT,
    allowNull: false
  }
});

// Define relationships: A User has many Notes
User.hasMany(Note, { onDelete: 'CASCADE' });
Note.belongsTo(User);

// Sync models with the database (in production, consider using migrations)
sequelize.sync();

/* ==========================================
   Helper Middleware for Authentication
   ========================================== */

function isAuthenticated(req, res, next) {
  if (req.session && req.session.userId) {
    next();
  } else {
    res.status(401).json({ error: 'Unauthorized' });
  }
}

/* ==========================================
   Routes for Authentication
   ========================================== */

// Register a new user
app.post('/register', async (req, res) => {
  try {
    const { username, password } = req.body;

    // Basic validation – adjust these rules as needed
    if (!username || !password || typeof username !== 'string' || typeof password !== 'string') {
      return res.status(400).json({ error: 'Invalid username or password' });
    }
    if (username.length > 50) {
      return res.status(400).json({ error: 'Username too long' });
    }

    // Hash the password with a salt factor (12 rounds)
    const passwordHash = await bcrypt.hash(password, 12);

    const user = await User.create({ username, passwordHash });
    req.session.userId = user.id;

    res.status(201).json({ message: 'User registered successfully' });
  } catch (err) {
    if (err.name === 'SequelizeUniqueConstraintError') {
      return res.status(400).json({ error: 'Username already exists' });
    }
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Log in an existing user
app.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password required' });
    }

    const user = await User.findOne({ where: { username } });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const match = await bcrypt.compare(password, user.passwordHash);
    if (!match) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    req.session.userId = user.id;
    res.json({ message: 'Logged in successfully' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Log out the current user
app.post('/logout', isAuthenticated, (req, res) => {
  req.session.destroy(err => {
    if (err) {
      return res.status(500).json({ error: 'Could not log out, please try again' });
    }
    res.json({ message: 'Logged out successfully' });
  });
});

// Endpoint to fetch CSRF token (useful for clients that need it)
app.get('/csrf-token', (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

/* ==========================================
   Routes for Note CRUD Operations
   ========================================== */

// Get all notes for the authenticated user
app.get('/notes', isAuthenticated, async (req, res) => {
  try {
    const notes = await Note.findAll({
      where: { UserId: req.session.userId },
      order: [['createdAt', 'DESC']]
    });
    res.json({ notes });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create a new note
app.post('/notes', isAuthenticated, async (req, res) => {
  try {
    const { content } = req.body;
    if (!content || typeof content !== 'string') {
      return res.status(400).json({ error: 'Invalid note content' });
    }

    const note = await Note.create({ content, UserId: req.session.userId });
    res.status(201).json({ note });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update an existing note
app.put('/notes/:id', isAuthenticated, async (req, res) => {
  try {
    const { content } = req.body;
    if (!content || typeof content !== 'string') {
      return res.status(400).json({ error: 'Invalid note content' });
    }

    // Ensure the note belongs to the authenticated user
    const note = await Note.findOne({
      where: { id: req.params.id, UserId: req.session.userId }
    });
    if (!note) {
      return res.status(404).json({ error: 'Note not found' });
    }

    note.content = content;
    await note.save();

    res.json({ note });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete a note
app.delete('/notes/:id', isAuthenticated, async (req, res) => {
  try {
    // Ensure the note belongs to the authenticated user
    const note = await Note.findOne({
      where: { id: req.params.id, UserId: req.session.userId }
    });
    if (!note) {
      return res.status(404).json({ error: 'Note not found' });
    }

    await note.destroy();
    res.json({ message: 'Note deleted successfully' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/* ==========================================
   Global Error Handler
   ========================================== */

// Handle CSRF token errors specifically
app.use((err, req, res, next) => {
  if (err.code === 'EBADCSRFTOKEN') {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  console.error(err);
  res.status(500).json({ error: 'Internal server error' });
});

/* ==========================================
   Start the Server
   ========================================== */

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
